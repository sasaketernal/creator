<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Mini Pac-Man: Just Create Edition</title>
  <style>
    :root {
      --card-bg: #0f1118;
      --sidebar-bg: #12141b;
      --page-bg: #0e0f13;
      --text: #e6e6ea;
      --muted: #9aa2b1;
      --border: #22252e;
      --brand: #2b7cff;
    }

    * { box-sizing: border-box; }
    body {
      font-family: system-ui, Arial, sans-serif;
      margin: 0;
      color: var(--text);
      display: flex;
      min-height: 100vh;
      background: url("/bgx.png") no-repeat center/cover fixed;
    }
    body::before {
      content: "";
      position: fixed; inset: 0;
      background: radial-gradient(1200px 800px at 70% 30%, transparent 0, rgba(0,0,0,.25) 50%, rgba(0,0,0,.6) 100%);
      pointer-events: none;
      z-index: 0;
    }

    .sidebar {
      position: relative; z-index: 1;
      width: 340px; padding: 16px;
      border-right: 1px solid var(--border);
      background: color-mix(in srgb, var(--sidebar-bg) 88%, transparent);
      backdrop-filter: blur(6px);
    }
    .sidebar h1 { font-size: 20px; margin: 8px 0 8px; }
    .brand { display:flex; align-items:center; gap:10px; margin-bottom: 12px; }
    .brand img { width: 40px; height: 40px; object-fit: contain; border-radius: 8px; background: #0c0f15; border:1px solid var(--border); }

    .card { background: var(--card-bg); border:1px solid var(--border); border-radius:12px; padding:12px; margin-bottom:12px; }
    .row { display:flex; gap:8px; align-items:center; }
    .row > * { flex: 1 1 auto; }
    .muted { color: var(--muted); font-size:12px; }
    .btn { background: var(--brand); color:white; border:none; padding:8px 12px; border-radius:8px; cursor:pointer; }
    .btn.secondary { background:#1f2430; color:#d2d6e1; border:1px solid #2a2f3a; }
    .btn:disabled { opacity:.5; cursor:not-allowed; }
    .value { font-weight:600; }
    .name-input { width:100%; padding:10px; border-radius:8px; background:#0c0f15; color:var(--text); border:1px solid var(--border); }

    .main { flex:1; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:12px; padding:16px; position: relative; z-index: 1; }
    canvas { background:#000; border:1px solid var(--border); border-radius:12px; box-shadow:0 8px 32px rgba(0,0,0,.35); image-rendering: pixelated; }

    .toast { position:fixed; top:12px; right:12px; background:#10131a; color:#cfe1ff; border:1px solid #2b7cff55; border-radius:10px; padding:8px 12px; font-size:14px; display:none; z-index: 3; }

    dialog { background:var(--card-bg); color:var(--text); border:1px solid var(--border); border-radius:12px; padding:0; max-width:520px; width:92vw; }
    dialog::backdrop { background: rgba(0,0,0,.6); }
    .dl-header { padding:14px 16px; border-bottom:1px solid var(--border); display:flex; align-items:center; justify-content:space-between; }
    .dl-body { padding:16px; }
    .tbl { width:100%; border-collapse: collapse; }
    .tbl th, .tbl td { padding:8px; border-bottom:1px solid var(--border); text-align:left; }
    .tbl th { font-size:12px; color:var(--muted); font-weight:500; }
  </style>
</head>
<body>
  <aside class="sidebar">
    <div class="brand">
      <img src="https://pbs.twimg.com/profile_images/1964461521402286088/od6DPRUv_400x400.jpg" alt="Logo" />
      <h1>Mini Pacman</h1>
    </div>

    <div class="card">
      <div class="row">
        <button id="btnStart" class="btn">Start / Reset (R)</button>
        <button id="btnPause" class="btn secondary">Pause (P)</button>
      </div>
      <p class="muted">Use arrow keys ← ↑ → ↓ to move. Eat dots (•) for points, avoid ghosts.</p>
    </div>

    <div class="card">
      <div class="row"><div>Score:</div><div class="value" id="score">0</div></div>
      <div class="row"><div>Lives:</div><div class="value" id="lives">3</div></div>
      <div class="row"><div>Level:</div><div class="value" id="level">1</div></div>
    </div>

    <div class="card">
      <div class="row">
        <button id="btnLeaderboard" class="btn">View Leaderboard</button>
        <button id="btnClearLB" class="btn secondary">Clear</button>
      </div>
    </div>
  </aside>

  <main class="main">
    <canvas id="game" width="560" height="560" aria-label="Game board"></canvas>
  </main>

  <div class="toast" id="toast"></div>

  <dialog id="dlgLB">
    <div class="dl-header">
      <strong>Leaderboard</strong>
      <button class="btn secondary" id="btnCloseDlg">Close</button>
    </div>
    <div class="dl-body">
      <div id="saveArea" style="display:none; margin-bottom:12px;">
        <label class="muted" for="playerName">Save your score</label>
        <input id="playerName" class="name-input" maxlength="16" placeholder="Player name" />
        <div style="display:flex; gap:8px; margin-top:8px;">
          <button id="btnSaveScore" class="btn">Save</button>
          <button id="btnSkipSave" class="btn secondary">Skip</button>
        </div>
      </div>
      <table class="tbl" id="tblLB">
        <thead><tr><th>Rank</th><th>Name</th><th>Score</th><th>Date</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>
  </dialog>

  <script>
    // ====== Utils ======
    const rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
    function showToast(msg) {
      const el = document.getElementById('toast');
      el.textContent = msg; el.style.display='block';
      setTimeout(() => el.style.display='none', 1400);
    }

    // ====== Map (0 empty, 1 wall, 2 dot, 3 pellet) ======
    const W = 20, H = 20, TILE = 28;
    const baseMap = [
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,2,1,2,1,2,1,1,1,2,1,1,1,1,2,1],
      [1,3,1,0,1,2,1,2,1,2,1,0,1,2,1,0,0,1,2,1],
      [1,2,1,0,1,2,1,2,1,2,1,0,1,2,1,0,1,1,2,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,2,1,1,1,1,1,2,1,1,1,1,1,1,2,1],
      [1,2,2,2,1,2,2,2,2,0,2,2,2,2,1,2,2,2,2,1],
      [1,1,1,2,1,1,1,1,2,0,2,1,1,1,1,2,1,1,1,1],
      [0,0,1,2,2,2,2,1,2,0,2,1,2,2,2,2,1,2,0,0],
      [1,1,1,2,1,1,1,1,2,0,2,1,1,1,1,2,1,1,1,1],
      [1,2,2,2,1,2,2,2,2,0,2,2,2,2,1,2,2,2,2,1],
      [1,2,1,1,1,2,1,1,1,1,1,2,1,1,1,1,1,1,2,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,0,1,2,1,2,1,2,1,0,1,2,1,0,1,1,2,1],
      [1,3,1,0,1,2,1,2,1,2,1,0,1,2,1,0,0,1,2,1],
      [1,2,1,1,1,2,1,2,1,2,1,1,1,2,1,1,1,1,2,1],
      [1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,0,0,0,0,0,2,1,2,0,0,0,0,0,0,0,0,2,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ];

    // ====== Game state ======
    const ctx = document.getElementById('game').getContext('2d');
    let map, dotsLeft, score, lives, level, running = false, paused = false;
    const player = { x: 1, y: 1, dir: {x:1,y:0}, pending: {x:1,y:0}, speed: 6, power: 0, mouth: 0.25, mouthDir: 1 };
    const ghosts = [];

    // color pool for ghosts
    const ghostColors = ["#ff4d6d", "#4dd9ff", "#ffb84d", "#b84dff", "#72f1b8"];

    function reset(levelUp=false) {
      map = baseMap.map(row => row.slice());
      dotsLeft = 0; map.forEach(r=>r.forEach(c=>{ if(c===2) dotsLeft++; }));
      score = levelUp ? score : 0;
      lives = levelUp ? lives : 3;
      level = levelUp ? level+1 : 1;
      Object.assign(player, { x:1, y:1, dir:{x:1,y:0}, pending:{x:1,y:0}, power:0, mouth:0.25, mouthDir: 1 });
      ghosts.length = 0;
      const gCount = Math.min(4, 2 + Math.floor(level/2));
      for (let i=0;i<gCount;i++) ghosts.push(makeGhost(18-i, 18, 4+i, ghostColors[i % ghostColors.length]));
      running = true; paused = false;
      document.getElementById('level').textContent = level;
      document.getElementById('score').textContent = score;
      document.getElementById('lives').textContent = lives;
      lastTime = performance.now();
    }

    function makeGhost(x,y,speed,color){ return { x, y, dir: {x:-1,y:0}, speed, scared: 0, scatter: 0, color }; }

    // ====== Movement ======
    function canMove(nx, ny) { if (nx < 0) nx = W-1; if (nx >= W) nx = 0; if (ny < 0 || ny >= H) return false; return map[ny][nx] !== 1; }
    function stepEntity(ent, dt) {
      ent._acc = (ent._acc || 0) + ent.speed * dt;
      while (ent._acc >= 1) {
        const nx = ent.x + ent.dir.x;
        const ny = ent.y + ent.dir.y;
        if (canMove(nx, ny)) { ent.x = (nx+W)%W; ent.y = ny; }
        else { ent.dir = {x:0,y:0}; }
        ent._acc -= 1;
      }
    }

    // ====== Input ======
    window.addEventListener('keydown', (e)=>{
      if (e.key.toLowerCase()==='r') return (reset(), void 0);
      if (e.key.toLowerCase()==='p') return (paused = !paused, void 0);
      const m = { ArrowLeft:{x:-1,y:0}, ArrowRight:{x:1,y:0}, ArrowUp:{x:0,y:-1}, ArrowDown:{x:0,y:1} }[e.key];
      if (m) player.pending = m;
    });

    // ====== Ghost AI ======
    function updateGhost(gh) {
      if (gh.scared > 0) { gh.scared--; }
      if (gh.scatter-- <= 0 || !canMove(gh.x+gh.dir.x, gh.y+gh.dir.y)) {
        const options = [];
        const dirs = [ {x:1,y:0}, {x:-1,y:0}, {x:0,y:1}, {x:0,y:-1} ];
        for (const d of dirs) if (canMove(gh.x + d.x, gh.y + d.y)) options.push(d);
        options.sort((a,b)=>{
          const ax = gh.x + a.x, ay = gh.y + a.y;
          const bx = gh.x + b.x, by = gh.y + b.y;
          const da = Math.abs(ax - player.x) + Math.abs(ay - player.y);
          const db = Math.abs(bx - player.x) + Math.abs(by - player.y);
          return (gh.scared>0 ? db - da : da - db);
        });
        gh.dir = options[0] || {x:0,y:0};
        gh.scatter = rand(6, 18);
        // change color occasionally for fun
        if (Math.random() < 0.25) gh.color = ghostColors[rand(0, ghostColors.length-1)];
      }
    }

    // ====== Loop ======
    let lastTime = performance.now();
    function loop(ts){ if (!running) return; const dt = Math.min(0.05, (ts - lastTime)/1000); lastTime = ts; if (!paused) update(dt); render(); requestAnimationFrame(loop); }

    function update(dt){
      // Turn when possible
      if (canMove(player.x + player.pending.x, player.y + player.pending.y)) player.dir = player.pending;
      stepEntity(player, dt);

      // Mouth animation: oscillate between 0.05 and 0.45 radians
      const speedFactor = (player.dir.x!==0 || player.dir.y!==0) ? 1 : 0.4; // slower when idle
      player.mouth += player.mouthDir * 3.2 * dt * speedFactor;
      if (player.mouth > 0.45) { player.mouth = 0.45; player.mouthDir = -1; }
      if (player.mouth < 0.05) { player.mouth = 0.05; player.mouthDir = 1; }

      // Eat
      if (map[player.y][player.x] === 2) { map[player.y][player.x] = 0; score += 10; dotsLeft--; }
      if (map[player.y][player.x] === 3) { map[player.y][player.x] = 0; score += 50; player.power = 400; ghosts.forEach(g=>g.scared = 400); }

      // Ghosts
      ghosts.forEach(g=>{ updateGhost(g); stepEntity(g, dt); });

      // Collisions
      for (const g of ghosts) {
        if (g.x === player.x && g.y === player.y) {
          if (player.power > 0 || g.scared>0) { score += 200; g.x = 18; g.y = 18; g.scared = 0; showToast('Ghost captured! +200'); }
          else {
            lives--; showToast('Caught! -1 life');
            Object.assign(player, { x:1, y:1, dir:{x:1,y:0}, pending:{x:1,y:0}, mouth:0.25, mouthDir:1 });
            if (lives<=0) { running=false; gameOver(); return; }
          }
        }
      }

      // Power timer
      if (player.power>0) player.power--;

      // Level complete
      if (dotsLeft<=0) { showToast('Level up!'); nextLevel(); }

      // UI
      document.getElementById('score').textContent = score;
      document.getElementById('lives').textContent = lives;
    }

    function render(){
      ctx.clearRect(0,0, W*TILE, H*TILE);
      // Map
      for (let y=0;y<H;y++) for (let x=0;x<W;x++) {
        const t = map[y][x];
        if (t===1) { // wall
          ctx.fillStyle = '#1c2a4a';
          ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
          ctx.strokeStyle = '#2b7cff55';
          ctx.strokeRect(x*TILE+2, y*TILE+2, TILE-4, TILE-4);
        } else if (t===2) { // dot
          ctx.fillStyle = '#ffd166';
          ctx.beginPath(); ctx.arc(x*TILE+TILE/2, y*TILE+TILE/2, 3, 0, Math.PI*2); ctx.fill();
        } else if (t===3) { // power pellet
          ctx.fillStyle = '#72f1b8';
          ctx.beginPath(); ctx.arc(x*TILE+TILE/2, y*TILE+TILE/2, 6, 0, Math.PI*2); ctx.fill();
        }
      }

      // Player with opening/closing mouth
      const px = player.x*TILE + TILE/2, py = player.y*TILE + TILE/2, r = TILE*0.35;
      let base = 0; // facing right
      if (player.dir.x===-1) base = Math.PI;
      else if (player.dir.y===-1) base = -Math.PI/2;
      else if (player.dir.y===1) base = Math.PI/2;
      let start = base + player.mouth;
      let end = base - player.mouth;
      // draw the LARGE sector (body) by ensuring end > start and spanning > PI
      if (end < start) end += Math.PI * 2;
      ctx.fillStyle = player.power>0 ? '#72f1b8' : '#ffcd00';
      ctx.beginPath();
      ctx.moveTo(px, py);
      ctx.arc(px, py, r, start, end); // clockwise, big arc
      ctx.closePath();
      ctx.fill();
      // simple eye
      const eyeOffsetX = Math.cos(base) * r * 0.35 - Math.sin(base) * r * 0.15;
      const eyeOffsetY = Math.sin(base) * r * 0.35 + Math.cos(base) * r * 0.15;
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(px + eyeOffsetX, py + eyeOffsetY, 2, 0, Math.PI*2);
      ctx.fill();

      // Ghosts
      for (const g of ghosts) {
        ctx.fillStyle = g.scared>0 ? '#6c7a89' : g.color || '#ff4d6d';
        const gx = g.x*TILE + TILE/2, gy = g.y*TILE + TILE/2;
        ctx.beginPath(); ctx.arc(gx, gy, TILE*0.34, Math.PI, 0); ctx.fill();
        ctx.fillRect(gx - TILE*0.34, gy, TILE*0.68, TILE*0.34);
      }
    }

    // ====== Level & GameOver ======
    function nextLevel(){ running=false; setTimeout(()=>{ reset(true); }, 600); }
    function gameOver(){ showLeaderboard(true); }

    // ====== Leaderboard ======
    const LB_KEY = 'mini-pacman-lb';
    function getLB(){ try { return JSON.parse(localStorage.getItem(LB_KEY)) || []; } catch { return []; } }
    function setLB(rows){ localStorage.setItem(LB_KEY, JSON.stringify(rows)); }
    function addScore(name, score){
      const rows = getLB();
      rows.push({ name: (name||'Anon').slice(0,16), score, at: new Date().toISOString() });
      rows.sort((a,b)=> b.score - a.score);
      setLB(rows.slice(0, 20));
    }

    function showLeaderboard(offerSave=false){
      const dlg = document.getElementById('dlgLB');
      const body = dlg.querySelector('tbody');
      body.innerHTML = '';
      const rows = getLB();
      rows.forEach((r,i)=>{
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${i+1}</td><td>${r.name}</td><td>${r.score}</td><td>${new Date(r.at).toLocaleString()}</td>`;
        body.appendChild(tr);
      });
      const save = document.getElementById('saveArea');
      save.style.display = offerSave ? 'block' : 'none';
      dlg.showModal();
      if (offerSave) { document.getElementById('playerName').focus(); }
    }

    // ====== UI wiring ======
    document.getElementById('btnStart').onclick = ()=> reset();
    document.getElementById('btnPause').onclick = ()=> { paused = !paused; };
    document.getElementById('btnLeaderboard').onclick = ()=> showLeaderboard(false);
    document.getElementById('btnClearLB').onclick = ()=> { localStorage.removeItem(LB_KEY); showToast('Leaderboard cleared'); };
    document.getElementById('btnCloseDlg').onclick = ()=> document.getElementById('dlgLB').close();
    document.getElementById('btnSaveScore').onclick = ()=> {
      const name = document.getElementById('playerName').value.trim() || 'Anon';
      addScore(name, score);
      showToast('Score saved');
      document.getElementById('saveArea').style.display='none';
      const body = document.querySelector('#tblLB tbody');
      body.innerHTML = '';
      getLB().forEach((r,i)=>{
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${i+1}</td><td>${r.name}</td><td>${r.score}</td><td>${new Date(r.at).toLocaleString()}</td>`;
        body.appendChild(tr);
      });
    };
    document.getElementById('btnSkipSave').onclick = ()=> document.getElementById('dlgLB').close();

    // Boot
    reset();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
